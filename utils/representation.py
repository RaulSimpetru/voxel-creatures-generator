import os
import pickle
import shutil
from datetime import datetime
from functools import partial, reduce
from operator import itemgetter
from typing import Optional, List, Dict, Tuple, Iterator, Iterable, TypedDict

import numpy as np

CUBE_COORDINATES = np.array(
    [
        [-0.5, -0.5, -0.5],
        [0.5, -0.5, -0.5],
        [-0.5, 0.5, -0.5],
        [0.5, 0.5, -0.5],
        [-0.5, -0.5, 0.5],
        [0.5, -0.5, 0.5],
        [-0.5, 0.5, 0.5],
        [0.5, 0.5, 0.5],
    ]
)

STANDARD_FACES = np.array([[1, 5, 7, 3], [2, 4, 8, 6], [1, 2, 6, 5], [3, 7, 8, 4], [1, 3, 4, 2], [5, 6, 8, 7]])

# Can be changed to fit your input
STANDARD_SHAPE = np.array([64, 32, 40])

FUNCTIONS_DICT = {
    (255, 0, 0): "head",  # red
    (0, 255, 255): "tail",  # cyan
    (0, 255, 0): "arm_left",  # green
    (255, 0, 255): "arm_right",  # magenta
    (0, 0, 255): "leg_left",  # blue
    (255, 255, 0): "leg_right",  # yellow
}

DictRepresentation = TypedDict(
    "DictRepresentation",
    {"f_name": str, "cubes": Dict[int, Dict[str, np.ndarray]], "function": List[Optional[Tuple[str, np.ndarray]]]},
)

AbstractRepresentation = TypedDict("AbstractRepresentation", {"f_name": str, "cubes": np.ndarray})


def plys_to_dict_reps(input_dir: str, *, files_to_convert: Optional[List[str]] = None) -> Iterator[DictRepresentation]:
    for f_name in os.listdir(input_dir) if files_to_convert is None else files_to_convert:
        with open(os.path.join(input_dir, f_name)) as file:
            lines = list(map(lambda x: x.replace("\n", ""), file.readlines()))

        nr_of_vertices = int(lines[3].split(" ")[-1])
        start_to_read = int(lines.index("end_header")) + 1

        output_dict = {
            "f_name": f_name.replace(".ply", ""),
            "cubes": {
                i: {
                    "pos": np.array(
                        [
                            np.sum(list(map(itemgetter(0), value["v"]))) / 8,
                            np.sum(list(map(itemgetter(1), value["v"]))) / 8,
                            np.sum(list(map(itemgetter(2), value["v"]))) / 8,
                        ],
                        dtype=int,
                    ),
                    "color": value["c"],
                }
                for i, value in {
                    i: {
                        "v": [
                            np.round(np.array(line.split(" ")[:3], dtype=float) - 0.005, 1) * 10
                            + np.array([0.5, 0.5, -0.5])
                            for line in lines[start_to_read + 8 * i : start_to_read + 8 * (1 + i)]
                        ],
                        "f": [
                            np.array(line.split(" ")[1:], dtype=int)
                            for line in lines[
                                start_to_read + nr_of_vertices + 6 * i : start_to_read + nr_of_vertices + 6 * (1 + i)
                            ]
                        ],
                        "c": np.array(lines[start_to_read + 8 * (1 + i) - 1].split(" ")[3:], dtype=int),
                    }
                    for i in range(int(nr_of_vertices / 8))
                }.items()
            },
        }

        translation_vector = np.apply_along_axis(np.min, 0, [x["pos"] for x in output_dict["cubes"].values()])
        function_list = []

        for value in output_dict["cubes"].values():
            value["pos"] -= translation_vector

            if (color_tuple := tuple(value["color"])) in FUNCTIONS_DICT:
                function_list.append((FUNCTIONS_DICT[color_tuple], value["pos"]))

        output_dict["function"] = function_list

        yield output_dict


def dict_reps_to_objs(
    dict_reps_to_convert: Iterable[DictRepresentation],
    output_dir: str,
    *,
    files_to_convert: Optional[List[str]] = None,
    output_name: Optional[str] = None,
):
    for dict_rep in (
        dict_reps_to_convert
        if files_to_convert is None
        else filter(lambda x: x["f_name"] in files_to_convert, dict_reps_to_convert)
    ):
        vs = []
        fs = []

        for i, data in dict_rep["cubes"].items():
            vs.extend(list(map(lambda x: f"v {x[0]} {x[1]} {x[2]}\n", data["pos"] + CUBE_COORDINATES)))
            fs.extend(list(map(lambda x: f"f {x[0]} {x[1]} {x[2]} {x[3]}\n", STANDARD_FACES + (8 * i))))

        with open(
            os.path.join(output_dir, f"{dict_rep['f_name'] if output_name is None else output_name}.obj"), "w+"
        ) as f:
            f.writelines(
                [
                    "# File generated by VoxelCreaturesGenerator\n",
                    "# Made by the one and only:\n",
                    "# (Prof. Dr.)* Raul C. SÃ®mpetru <raul.simpetru@fau.de>\n",
                    "# * Remove parenthesis in a few years and add titles if necessary :)\n\n",
                    f"# Generated on {datetime.now().strftime('%d.%m.%Y at %H:%M:%S')}\n\n\n\n",
                ]
            )

            f.write("# Vertices\n")
            f.writelines(vs)

            f.write("\n")

            f.write("# Faces\n")
            f.writelines(fs)

            f.truncate()


def combine_parts(
    dict_reps_to_combine: List[DictRepresentation], body_file: str, output_name: str
) -> DictRepresentation:
    function_and_pos_body_dict = {}
    body_dict_rep = list(filter(lambda x: x["f_name"] == body_file, dict_reps_to_combine))[0]
    output = {"f_name": output_name, "cubes": body_dict_rep["cubes"], "function": []}
    to_add = {}

    if len(body_dict_rep["function"]) > 0:
        function_and_pos_body_dict = dict(body_dict_rep["function"])

    for function, _ in function_and_pos_body_dict.items():
        for dict_rep in dict_reps_to_combine:
            if dict_rep["f_name"] != body_file and function == dict_rep["function"][0][0]:
                to_add[function] = (
                    dict_rep["f_name"],
                    dict_rep["function"][0][1],
                )

    for function, data in to_add.items():
        index_shift = len(output["cubes"])
        pos_shift = np.subtract(function_and_pos_body_dict[function], data[1])

        i = 0

        for value in list(filter(partial(lambda x, d="": x["f_name"] == d, d=data[0]), dict_reps_to_combine))[0][
            "cubes"
        ].values():
            if not np.array_equal(value["pos"], data[1]):
                new_val = value
                new_val["pos"] += pos_shift

                # Assure duplicates are not added
                if list(new_val["pos"]) not in list(map(lambda x: list(x["pos"]), output["cubes"].values())):
                    output["cubes"][index_shift + i] = new_val
                    i += 1

    return output


def dict_reps_to_abstract_reps(
    dict_reps_to_convert: Iterable[DictRepresentation],
) -> Iterator[AbstractRepresentation]:
    for dict_rep in dict_reps_to_convert:
        shift = np.apply_along_axis(np.min, 0, [x["pos"] for x in dict_rep["cubes"].values()])

        temp = np.zeros(STANDARD_SHAPE, dtype=np.float32)

        for array_index in map(itemgetter("pos"), dict_rep["cubes"].values()):
            temp[tuple(np.subtract(array_index, shift))] = 1

        yield {"f_name": dict_rep["f_name"], "cubes": temp}


def abstract_reps_to_dict_reps(
    abstract_reps_to_convert: Iterable[AbstractRepresentation],
) -> Iterator[DictRepresentation]:
    return (
        {
            "f_name": abstract_rep["f_name"],
            "cubes": {i: {"pos": pos} for i, pos in enumerate(np.argwhere(abstract_rep["cubes"] == 1).astype(int))},
        }
        for abstract_rep in abstract_reps_to_convert
    )


def abstract_reps_to_pickles(
    abstract_reps_to_convert: Iterable[AbstractRepresentation], output_dir: str, *, output_name: str = None
):
    for abstract_rep in abstract_reps_to_convert:
        with open(
            os.path.join(
                output_dir, f"{abstract_rep['f_name']}.pickle" if output_name is None else f"{output_name}.pickle"
            ),
            "wb",
        ) as out_file:
            pickle.dump(abstract_rep["cubes"], out_file, pickle.HIGHEST_PROTOCOL)


def pickles_to_abstract_reps(
    input_dir: str, *, files_to_convert: Optional[List[str]] = None
) -> Iterator[AbstractRepresentation]:
    for file in (
        filter(lambda x: x in files_to_convert, os.listdir(input_dir))
        if files_to_convert is not None
        else os.listdir(input_dir)
    ):
        with open(os.path.join(input_dir, file), "rb") as input_file:
            to_return = {"f_name": file, "cubes": pickle.load(input_file)}

        yield to_return


def sort_files_in_dirs(input_dir: str):
    _, _, f_names = list(os.walk(input_dir))[0]

    for dict_rep in plys_to_dict_reps(input_dir, files_to_convert=f_names):
        f_name_path = os.path.join(input_dir, f"{dict_rep['f_name']}.ply")

        if len(dict_rep["function"]) > 1:
            shutil.move(
                f_name_path,
                os.path.join(os.path.join(input_dir, "body"), f"{dict_rep['f_name']}.ply"),
            )
            continue

        shutil.move(
            f_name_path,
            os.path.join(os.path.join(input_dir, dict_rep["function"][0][0]), f"{dict_rep['f_name']}.ply"),
        )


def make_random_creatures(n: int, input_dir: str, *, only_uniques: bool = False) -> Iterator[DictRepresentation]:
    _, d_names, _ = list(os.walk(input_dir))[0]
    already_used_combinations = []
    body_parts_shopping_list = {d_name: os.listdir(os.path.join(input_dir, d_name)) for d_name in d_names}

    nr_of_possibilities = reduce(
        lambda x, y: x * len(y), (v for k, v in body_parts_shopping_list.items() if k != "leg_left"), 1
    )

    if only_uniques and n > nr_of_possibilities:
        raise ValueError(
            f"Can not create {n} uniques with given data! Maximal number of uniques is {nr_of_possibilities}!"
        )

    while n > 0:
        body_dict_rep = list(
            plys_to_dict_reps(
                os.path.join(input_dir, "body"),
                files_to_convert=np.random.choice(body_parts_shopping_list["body"], 1),
            )
        )[0]

        body_parts = []

        functions = list(map(itemgetter(0), body_dict_rep["function"]))

        if "leg_left" in functions:
            leg_left_dict_rep = list(
                plys_to_dict_reps(
                    os.path.join(input_dir, "leg_left"),
                    files_to_convert=np.random.choice(body_parts_shopping_list["leg_left"], 1),
                )
            )

            leg_right_dict_rep = list(
                plys_to_dict_reps(
                    os.path.join(input_dir, "leg_right"),
                    files_to_convert=list(
                        filter(
                            lambda x: leg_left_dict_rep[0]["f_name"].split("-")[0] in x,
                            body_parts_shopping_list["leg_right"],
                        )
                    )[:1],
                )
            )

            for _ in range(functions.count("leg_left")):
                body_parts.extend(leg_left_dict_rep)
                functions.remove("leg_left")

            for _ in range(functions.count("leg_right")):
                body_parts.extend(leg_right_dict_rep)
                functions.remove("leg_right")

        for function in functions:
            body_parts.extend(
                plys_to_dict_reps(
                    os.path.join(input_dir, str(function)),
                    files_to_convert=np.random.choice(body_parts_shopping_list[function], 1),
                )
            )

        body_parts.append(body_dict_rep)

        to_yield = partial(combine_parts, body_parts, body_parts[-1]["f_name"], str(n - 1))

        if only_uniques:
            if (body_parts_set := set(map(itemgetter("f_name"), body_parts))) not in already_used_combinations:
                already_used_combinations.append(body_parts_set)
                n -= 1
                yield to_yield()

            continue

        n -= 1
        yield to_yield()


def correct_abstract_reps_for_display(
    abstract_reps_to_convert: Iterable[AbstractRepresentation],
) -> Iterator[AbstractRepresentation]:
    return (
        {"f_name": abstract_rep["f_name"], "cubes": np.rot90(abstract_rep["cubes"], axes=(2, 1))}
        for abstract_rep in abstract_reps_to_convert
    )
